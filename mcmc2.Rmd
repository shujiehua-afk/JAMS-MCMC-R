---
title: "mcmc-2"
author: "Shujie Hua"
date: "2025-11-21"
output: html_document
---

```{r}
set.seed(1)

n  <- 50000
b  <- 0.03

# 1. 采样基准二维高斯
library(MASS)
Sigma <- matrix(c(100, 0,
                   0, 1), nrow = 2)
x     <- mvrnorm(n, mu = c(0,0), Sigma = Sigma)
x1    <- x[,1]
x2    <- x[,2]

plot(x1, x2, pch=20, cex=0.4, col=rgb(0,0,0,0.3),
     xlab="x1", ylab="x2", main="original Distribution")

# 2. 施加香蕉变换
y1 <- x1
y2 <- x2 + b * (x1^2 - 100)

# 3. 绘图
plot(y1, y2, pch=20, cex=0.4, col=rgb(0,0,0,0.3),
     xlab="y1", ylab="y2", main="2D Banana-shaped Distribution")

```



```{r}
library(mvtnorm)
# ---------------Input--------------- #
beta <- c(1,0.8,0.6,0.4)  # temper_0,1,2 beta_0 = 1
temper_num <- length(beta)

target <- function(x){
  0.5 * dmvnorm(x, mean = c(-2, -2), sigma = diag(2)) +
  0.5 * dmvnorm(x, mean = c( 2,  2), sigma = diag(2))
}

start_where <- rep(list(c(0,0)), temper_num)
Sigma       <- rep(list(diag(2)),temper_num)
step <- 1000
```

```{r}
# ---------------Iteration--------------- #
parallel_tempering<- function(beta, temper_num, target, start_where,Sigma,step,d){
  record          <- array(NA_real_, dim = c(temper_num,(step+1),d))
  proposal_points <- array(NA_real_, dim = c(temper_num,step    ,d))
  prob.all        <- matrix(0      , nrow = temper_num, ncol = (2*step))
  
  for (i in 1:temper_num){
    record[i,1,] <- start_where[[i]]
  }
  
  # temper_num = even
  for (s in 1:step){
    for (temper in 1:temper_num){
      # ---------------Local jump--------------- #
      original_point              <- record[temper, s,]
      # 先把proposal_points的对应位置改成local提议点
      proposal_points[temper,s,]  <- rmvnorm(1, original_point, Sigma[[temper]])
      # prob.all 2s-1列记录第s次更新，初始点        的target()
      # prob.all 2s  列记录第s次更新，local_proposal的target()
      prob.all[temper,2*s-1]     <- target(original_point)
      prob.all[temper,2*s]       <- target(proposal_points[temper,s,])
      
      # 计算acceptance rate
      # acc_rate_local <- min(1, target(propose_local)^beta[temper]/target(original_point)^beta[temper])
      acc_rate_local <- min(1, exp(beta[temper]*(log(prob.all[temper,2*s])-log(prob.all[temper,2*s-1]))))
      
      
      u_local <- runif(1)
      if (u_local<acc_rate_local){
        proposal_points[temper,s,] <- proposal_points[temper,s,]
      }else{
        # 如果拒绝更换位置
        # proposal_points的对应位置改回第s次更新初始点
        # prob.all 2s列对应修改，保证始终反应proposal_points的s列的target()
        proposal_points[temper,s,] <- original_point
        prob.all[temper,2*s]       <- prob.all[temper,2*s-1]
      }
    }
    
    # ---------------Swith decision--------------- #
    if (s%%2 == 1){
      for (k in seq(1, temper_num,2)){
        # 更换1<->2; 3<->4...
        original_point2 <- proposal_points[k  ,s,]
        propose_switch  <- proposal_points[k+1,s,]
        # 于是，target(propose_switch) 就是prob.all[k+1,2*s]
        #       target(original_point2)就是prob.all[k  ,2*s]
        
        
        # acc_rate_switch <- min(1, target(propose_switch)^(beta[k]-beta[k+1])*target(original_point2)^(beta[k+1]-beta[k]))
        acc_rate_switch <- min(1, exp(log(prob.all[k+1,2*s])*(beta[k]-beta[k+1])+log(prob.all[k,2*s])*(beta[k+1]-beta[k])))
        
  
        u_switch1 <- runif(1)
        if (u_switch1<acc_rate_switch){
          # 更新record的s+1列
          record[k  ,s+1,]   <- proposal_points[k+1,s,]
          record[k+1,s+1,]   <- proposal_points[k  ,s,]
        }else{
          record[k  ,s+1,]   <- proposal_points[k  ,s,]
          record[k+1,s+1,]   <- proposal_points[k+1,s,]
        }
      }
    }else{for (k in seq(2, temper_num-1,2)){
      # 更换2<->3; 4<->5...
        original_point2 <- proposal_points[k  ,s,]
        propose_switch  <- proposal_points[k+1,s,]
       
        # acc_rate_switch <- min(1, target(propose_switch)^(beta[k]-beta[k+1])*target(original_point2)^(beta[k+1]-beta[k]))
        acc_rate_switch <- min(1, exp(log(prob.all[k+1,2*s])*(beta[k]-beta[k+1])+log(prob.all[k,2*s])*(beta[k+1]-beta[k])))  
            
        u_switch1 <- runif(1)
        if (u_switch1<acc_rate_switch){
          # 更新record的s+1列
          record[k  ,s+1,]   <- proposal_points[k+1,s,]
          record[k+1,s+1,]   <- proposal_points[k  ,s,]
        }else{
          record[k  ,s+1,]   <- proposal_points[k  ,s,]
          record[k+1,s+1,]   <- proposal_points[k+1,s,]
        }
    }
      record[1         , s+1,] <- proposal_points[1         ,s,]
      record[temper_num, s+1,] <- proposal_points[temper_num,s,]
    }
  }
  return(list(out = record))
  }
```


```{r}
# length(beta) needs to be even
t0 <- proc.time()
out <- parallel_tempering(
          beta = c(1,0.8,0.6,0.4),
          temper_num = length(beta), 
          target = target, 
          start_where = start_where,
          Sigma = Sigma,
          step = 3000,
          d=2
          )
proc.time() - t0
```

```{r}
library(ggplot2)

make_df <- function(record, chain_id){
    nstep <- dim(record)[2]
    data.frame(
        x = record[chain_id, , 1],
        y = record[chain_id, , 2],
        chain = factor(chain_id)
    )
}

rec <- out$out   # out 为 parallel_tempering 的返回值

df_list <- lapply(1:dim(rec)[1], function(i) make_df(rec, i))
df <- do.call(rbind, df_list)

library(ggplot2)

ggplot(df, aes(x = x, y = y, color = chain)) +
    geom_point(size = 0.3)


```
```{r}

df5 <- data.frame(x = sapply(out[[1]][[1]], function(z) z[[1]]), y = sapply(out[[1]][[1]], function(z) z[[2]]) )
ggplot(df5, aes(x = x, y = y)) +
    geom_point(color = 'pink', size = 0.1) +
    stat_density_2d(
                    geom = "contour", 
                    color = "black")

```
```{r}
df6<- data.frame(x = sapply(out[[1]][[4]], function(z) z[[1]]), y = sapply(out[[1]][[4]], function(z) z[[2]]) )

ggplot(df6,aes(x=x, y= y),)+geom_point(color = 'purple', size = 0.1)+
    stat_density_2d(
                    geom = "contour", 
                    color = "black")
```
```{r}
num <- 11
pairs <- cbind(seq(1,num-1,2),seq(2,num,2))
pairs
```

